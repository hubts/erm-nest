# Architecture

## Overview

본 프로젝트는 MSA 구조를 가지기 위해, NestJS에서 제공하는 Monorepo를 기반으로 구현되었습니다.

NestJS Monorepo는 크게 2개의 디렉토리 구조를 가집니다:

-   `apps` : 실제 서비스를 구현하는 위치
-   `libs` : 공통으로 이용되는 라이브러리들을 구현하는 위치

본 프로젝트는, 각 디렉토리에서 다음과 같은 영역들을 구현합니다:

-   `apps/gateway` : 라우팅을 담당하는 게이트웨이 서비스
-   `apps/auth` : 인증/유저 로직을 담당하는 인증 마이크로서비스
-   `apps/event` : 이벤트 로직을 담당하는 이벤트 마이크로서비스

-   `libs/common` : 각 서비스들에서 이용 가능한 공통 코드(e.g. 가드, 데코레이터, 파이프, 에러 등) 구현
-   `libs/sdk` : 외부(프론트엔드)와 소통하는 인터페이스를 정의하는 SDK

## Request Journey

프로젝트 구조 내에서, 사용자의 요청이 도달 후 처리되는 로직 Journey는 아래와 같습니다:

(Pipe, Interceptor 등 구체적인 흐름 생략)

1. Gateway에 선언된 Controller로 Request가 도착합니다.
2. Validation 및 유저 조회/검증을 수행합니다.
3. 해당 마이크로서비스 RpcHandler로 Request가 전달됩니다.
4. RpcHandler는 각 로직을 담당하는 서비스 Providers를 통해 처리합니다.
5. 과정에서 Mapping(Mappers), DB처리(Repository, Schema) 등이 발생합니다.
6. 필요한 경우 주요 도메인 로직(Domain)이 실행됩니다.
7. 처리완료된 결과가 마이크로서비스 > Gateway를 통해 Response 반환됩니다.

## Features

본 아키텍처는 프론트엔드와의 협업(BFF)을 위한 SDK를 중심으로 구현/설계됩니다.

`libs/sdk` 를 참조하면, 두 개의 디렉토리를 확인할 수 있습니다.

-   `libs/sdk/interfaces`
-   `libs/sdk/types`

### Interfaces

도메인 서비스들의 인터페이스를 정의합니다. 다음과 같은 요소들이 구현됩니다.

-   프론트엔드 구현 및 컨트롤러(최상위 인터페이스) 구현에 이용할 수 있는 서비스 구현 인터페이스
    -   e.g. `AuthApi` 는 인증 서비스에서 구현되는 회원가입, 로그인 등에 대한 인터페이스를 선언합니다.
-   HTTP Method, Route, Roles 등 라우트 메소드 관련 설정
    -   e.g. `AuthRoute` 는 회원가입, 로그인 등의 각 기능들이 `GET`, `POST` 메소드로 선언되는지, 어떤 sub route를 가지는지, 해당 기능 호출에 필요한 권한들은 무엇인지 등을 설정합니다.
-   각 도메인 모델에 해당하는 인터페이스 정의
    -   e.g. `UserModel`, `UserRole` 등 도메인(데이터 응집체)을 미리 인터페이스로 선언하여 모델을 선언합니다. 이 모델들을 기반으로 프론트엔드와 리소스(또는 테이블 구조 등)에 대해 소통할 수 있습니다.

### Types

공통 응답 및 타입에 대해 정의합니다. 다음과 같은 요소들이 설정됩니다.

-   공통 응답 (페이지네이션 등)
-   라우트 및 구현 관련 인터페이스 (개발자 실수를 줄이는 인터페이스 정의)

### SDK (Interfaces & Types)

이렇게 상기 2가지, 인터페이스 및 타입들을 통해 백엔드와 프론트엔드가 구현/연동 시 동일한 인터페이스 및 버전 관리가 가능하도록 합니다.

이렇게 SDK가 구현 완료되면, 정의된 인터페이스들을 기반으로 Gateway Controller (프론트엔드와 가장 먼저 맞닿는 인터페이스 구현체)를 구현할 수 있습니다.

### Controller

Controller에서는 요청/응답 값을 어떻게 관리할지 정의합니다.

Controller에서 정의하는 인터페이스 및 구현체들은, 프론트엔드에서 그대로 호출하는 정보와 같기 때습니다. 따라서 앞서 구현된 `Api` 인터페이스를 기반으로 `implements` 합니다. 특히, 설정에 필요한 각 라우트 정보들 또한 `Route` 에서 구현되었기 때문에 그대로 주입/나열하면 됩니다.

Controller는 마이크로서비스들로 요청을 전달하고, 해당 처리된 결과를 응답으로 반환합니다. 이제 비즈니스 로직을 처리하기 위해 정해진 마이크로서비스(Client)를 호출합니다.

### RPC Handler

RPC Handler는 비즈니스 로직들을 일련적으로 수행하는, 비즈니스 로직 묶음입니다.

TCP 기반 마이크로서비스로 구현된 `Auth`, `Event` 는 각 RPC Handler를 구현하고 있으며, 앞선 Gateway Controller 에서 전달한 Payload를 기반으로 비즈니스 로직을 처리합니다.

마이크로서비스들의 각 RPC Handler는 또한 앞서 선언한 `Api` 인터페이스를 기반으로 인터페이스를 구현할 수 있기 때문에, 미리 정의된 인터페이스를 그대로 이용할 수 있습니다.

그리고 실질적인 비즈니스 로직은 이어지는 Providers 영역에서 구현됩니다.

### Providers

Providers는 가능한 단일 기능의 비즈니스 로직을 처리합니다. 예를 들어, 검사, CRUD, 데이터 변환 등 직접적인 모델에 대한 처리 및 Repository, Schema(Entity) 등을 다루는 역할을 수행합니다.

각 Provider끼리 서로에게 구현된 단일 비즈니스 로직을 호출하거나, 관련된 별도 Domain 기능들을 호출하여 하나의 메소드가 하나의 로직을 처리하도록 합니다.
